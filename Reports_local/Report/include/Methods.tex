\chapter{Methods}
\label{ch:Methods}

The purpose of this chapter is, based on the theory given in the previous chapter present an extended VAHSS construction that ensures honest clients by verifying that their inputs is from an allowed range or set. This will be done by first evaluating the performance of the range proofs and set membership proofs discussed the previous chapter to get an understanding of their advantages and disadvantages. Then determine which are more suitable to use in a extended VAHSS construction. In the section \ref{sec:combination} details on how to construct a server and client verifiable AHSS scheme is discussed. Section \ref{sec:aggregation} investigates the possibility of  improving of the combined construction by aggregating the  clients individual range proofs into one combined range proof. Then the final section discuss details about how to implement the construction presented in section \ref{sec:combination}.

\section{Comparison of constructions for verify clients honesty}
In this section the different constructions for verifying clients honesty presented in section \ref{sec:RF_theory} will be compared and discussed based on the purpose of including them the VAHSS Construction \ref{alg:VAHSS-HSS} . This is to obtain an understanding of their suitability to be combined with the VAHSS scheme to verify clients honesty. The aspects that  is of interest in when evaluating the compatibility with the VAHSS construction are:
\begin{itemize}
    \item Computation complexity  
    \item Proof size (communication complexity)
    \item Flexibility of range
\end{itemize}
The computational complexity affects the runtime, i.e it is important since it gives information about the runtime and what parameters that affects the runtime. Remark that the computational complexity in the verification  will become important when used in a VAHSS construction. There are usually many clients participating and thus the verification will grow linear with the number of clients. This is further discussed later in section \ref{sec:aggregation}. The size of the proof affects how many bits that needs to be sent by the prover to the verifier, this is not the most crucial aspects here, but it is still desired to keep this as low as possible. Finally the flexibility of the range determines the application areas, if for example a range proof can only be used to prove that a value is between $[0,10]$, and no other ranges. The application areas for such a range proof is highly limited. Further discussion will be made in the next sections where the considered range proofs and set membership proofs are compared.

Remark that all of the range proofs and set membership proofs considered aims to prove that the secret in a Pedersen commitment is in an allowed range (or set). Thus to combine any such proof with the VAHSS construction, the clients needs to publish a Pedersen commitment of their secret $x_i$. This is investigated further in section \ref{sec:combination} and it will be shown that the adaptation of the VAHSS construction to include a range proof is the same independent of the range proof used, hence the adaptability to VAHSS in not considers in the  following discussion and evaluation.

%The considerable difference between the Bulletproof and the signature based range proofs makes the comparison between them not straightforward.  Signature based range proofs requires bilinear mappings unlike Bulletproofs, bilinear mappings are relative expensive operation compared to for example group exponentials which are dominating  the computational complexity for Bulletproofs. Therefore it is not straightforward to compare them in aspects of number of operations performed and an explicit comparison will only be made with respect to runtime. But first the theoretical performance  and properties of the range proofs will be discussed individually.


\subsection{Theoretical analysis}
In this section the proofs will be discussed theoretically and then in the following section runtime for prototype implementations is  discussed.

A disadvantage for set membership proofs is the time consuming Setup phase, this phase has computational complexity of $\mathcal{O}(n)$, where $n=|\Phi|$. This comes from that the set membership proof requires digital signatures to be known by both prover and verifier, one signature for each elements in $\Phi$. The signatures are usually shared by the verifier in the Setup phase. Sharing the digital signatures of the elements in the set $\Phi$ becomes intractable when the set is large.  If it can be assumed that these signatures has been pre-shared, for example in applications where the same set of signatures are used many times, then the set membership can still be competitive to range proofs for applications requiring large sets. Large here refers to sets of size $>100$. 

The computational complexity will not be compared further theoretically since the Bulletproofs are considerably different compared to the set membership proof and signature based range proof. The latter requires bilinear mappings unlike Bulletproofs and bilinear mappings are comparatively expensive operations compared to group exponentials which are the operation dominating the computational complexity for Bulletproofs. Instead of comparing the theoretical computational complexity the runtime for prototype implementation of the different proof is considered in the next section. 

The communicational complexity of the proofs is not the most relevant feature of comparison for the aims of this paper, but it is still an important factor and hence the proof size is briefly discussed  for the different proofs. Given that the digital signatures are pre-shared the set membership provides a $\mathcal{O}(1)$-size set membership proof. The proof size for the signature based range proof is $\mathcal{O}\big(\frac{k}{log\: k- log\:log\:k}\big)$, where $l = \frac{k}{log\: u}, u = \frac{k}{log\: k}$ and for Bulletproofs $\mathcal{O}(log_2n)$. Thus it can be realised that the proof size for set membership is asymptotically smallest and signature based range proofs largest. 

An advantage of the set membership is that it allows to prove that a secret belongs to a set instead of a range and this is much more general. For example a set can be all prime numbers from $1-1000$, all odd numbers or just a random set of numbers. While the signature-based range proof and Bulletproof can only be use to prove belonging to a continuous range. In the paper presenting signature-based range proof is seen that a secret can be proven to belong to arbitrary ranges $[a,b]$ ,where that $a>0$ and $b>a$, and not only ranges where the lower bound is $0$. Considering arbitrary boundaries leads to a doubling of the computational complexity and communication complexity. 

Bulletproofs can also be modified to allow arbitrary range, $[a,b]$, with a similar approach as presented for the signature based range proofs and illustrated in Figure \ref{fig:interval}. A Bulletproof where one prover wishes to verify the range of several commitments can be optimised such that the  proof size does not growing multiplicatively in the number of commits but instead grows additive. More precisely, assume a prover wants to prove the range of $k$ commits a naive implementation would lead to a proof size of $k\cdot log_2 n $. An optimised implementation reduces this to $log_2 n + 2 log_2 k$.  Hence for the case of arbitrary intervals  proof size is increased with the additive term $2log_2 2 = 2$. 

Both for signature-based range proof and for Bulletproofs it is not the  size of interval that a secret is proved to belong to ($[a,b]$) that determines the complexity, it is the size of $u^l$ respective $2^n$ in the constructions. This is seen by how the bounds $a,b$ are just used for rewriting the secret and does not accurately affect the construction.
It is required that $b< u^l$ for the signature based range proof and $b<2^n$ for the Bulletproofs. Thus the complexity is not dependent on the size of the range but rather the upper limit, this leads to that a small range of large numbers results in longer runtime then a larger range of smaller numbers. Set membership proofs does not have this property since the runtime for the proof construction and verification is independent of the size and values of the elements in the set. 
%Concluding set membership proof allows proving belonging to much more flexible sets than the range proofs, but both range proofs considered can prove belonging to ranges $[a,b]$, where $a>0$ and $b>a$. 

\begin{comment}
\subsection{Theoretical analysis: Signature-based set membership and range proof}
First the communication complexity and proof is discussed, size starting with the signature based set membership . This construction allows for a $\mathcal{O}(1)$- size proof that a committed value belongs to a given set $\Phi$. In order to construct such a proof $n=|\Phi|$ digital signatures needs to be known by both prover and verifier, one signature for each elements in $\Phi$. This signatures are usually shared by the verifier in the Setup phase. Sharing the digital signatures of the elements in the set $\Phi$ becomes intractable when the set is large.  A large set in this context would be a set consisting of a few hundred elements since the verifier has to publish $n$ digital signatures in the SetUp phase. 

The signature based range proof reduces this to only needing to publish $u$ digital signatures to prove a commitment is in the range $[0,u^l]$ in the SetUp phase. In the algorithm \textbf{Prove} in Construction \ref{alg:ZKRP} the prover sends $l+1$ elements from the group $\mathds{G}_1$, $l$ elements from the group $\mathds{G}_T$ and $2l+1$ field elements. Comparing to the algorithm \textbf{Prove} in Construction \ref{alg:ZKSM} where the prover sends two elements from the group $\mathds{G}_1$, one elements from the group $\mathds{G}_T$ and three field elements. For the ZKRP the communication complexity depends on the choice of $u,l$. Asymptotic analysis gives a communication complexity $\mathcal{O}(\frac{k}{log\:k-log\:log\:k})$, where $l=\frac{k}{log\:u}$ and $u$ put to $u=\frac{k}{log\: k}$ Here $k$ satisfies $u^l \geq 2^{k-1}$.

For ZKSM the communicational complexity for the proof is lower then for the ZKRP, given $l>1$. In some practical applications the digital signatures shared in the setup phase can be assumed to be pre shared, for example in applications where $\Phi$ is used many times. This leads that ZKSM is to prefer over ZKRP in such applications or when $\Phi$ is a relative small. 

Next consider the computational complexity for algorithms \textbf{Prove} and \textbf{Verify} in the ZKSM and ZKRP. constructions  In the set membership construction both the prover and verifier has to perform one bilinear paring and two exponentials over the group $\mathds{G}$. While in the range proof construction the prover need to perform $l$ bilinear mappings and $5l$ exponentials to prove a secret is in the range $[0,u^l)$ and additionally $3l$ exponentials for arbitrary ranges $[a,b]$. The verifier need to ?? Discuss on meeting.
 %TODO
An advantage of the set membership construction is that it can prove membership of non continuous sets. An example could be that the set $\Phi$ represents all odd numbers in a certain interval and then the prover can insure the verifier that the secret is an odd number in a given range. This is an illustrative example of the flexibility of set membership proofs compared to range proofs.

\subsection{Theoretical analysis: Bulletproof}
First the communication and computational complexity of the inner product argument which is used in the Bulletproof is considered. Then based on this the Bulletproofs will be analysed.

The inner product argument as described in Construction \ref{alg:inner_product}, compared to the naive approach, reduces the communication complexity for proving the statement in equation \eqref{eq:IPA} from linear to logarithmic size in terms of the vecotrs length.  More precisely the prover has to send $2\lceil log_2 n \rceil$ group elements and $2$ field elements to the verifier when proving the statement, thus the commutation complexity id of order $\mathcal{O}(log_2 n)$, where $n$ is the length of the vectors. 

The computational effort for the inner product argument is dominated by $8n$ group exponentiations for the prover and  $4n$ group exponentiations for the  verifier. In a non-interactive construction this can be optimised such that the verifier instead perform only one multidimensional-exponent of size $2n+ 2log_2n +1$. This leads to a significant speed up of the verification of the argument.     

Using the inner product argument to build Bulletproofs result in a communication complexity of $2\lceil log_2 n \rceil +4$ group elements and $5$ field elements, where $n$ is such that a secret is proved to be in the range $[0,2^n)$.  A remark is that in a Bulletproof construction the range always has to be an exponent on $2$, if the length of the binary representation of the secret is not a two-exponent this can be solved with padding. When extending the Bulletproof to prove a secret is in an arbitrary range $[a,b]$ the communication complexity is increased by an additive term of size $2$.  

\end{comment}

\subsection{Prototype Analysis}
\label{sec:PrototypeAnalysis}
Implementation of Bulletproofs and signature-based range proof has been done  and compared between themselves in \cite{RANGE-SET}. That comparison  does not include results about the runtime for the set membership proof. In order to obtain a fair comparison between Bulletproofs, signature-based range proofs and set membership proofs the code used by \cite{RANGE-SET} is benchmarked for all three constructions on the same hardware. 

he reason for redoing the benchmarking for Bulletproof and signature based range proofs is since hardware differences would not lead to a fair comparison. Table \ref{tab:runtime} shows the time complexity comparison between Bulletproofs, signature-based range proofs and set membership proofs implemented in Golang (Go) with $128$- bit security level.  The settings for the benchmarking is the same as in \cite{RANGE-SET}  and the code obtain at \cite{Git:RP} is unchanged. The only difference compared to the comparison in \cite{RANGE-SET} is the hardware used and that set memberships proof are included in the comparison. 

The set used in the set membership proofs contains $182$ elements, which thereby the same amount of elements in the set as in the range, which is $[18,200]$, for the two range proofs 
% The comparison made by \cite{RANGE-SET} does not does not include results about the runtime for the set membership proof. The runtime for set membership proof included in Table \ref{tab:runtime} is obtained by the author of this paper by benchmarking the code found at \cite{Git:RP}. The settings used are the same as used to obtain the time complexity for the other two range proofs except the hardware parameters.
The computer used has a $1.6$ GHz Dual-Core Intel Core i$5-5250$U CPU, $8$GB $1600$ MHz DDR3 RAM  and running macOS $10.15$. 



%TODO test again
\begin{table}
	\centering
	\caption{Time complexity comparison for Bullerproofs, signature-based range proofs and set membership proofs. The benchmarking is done as  are described in section \ref{sec:PrototypeAnalysis}. The runtime are for implementations written in Golang and the code s are not optimized in runtime. }
	\label{tab:runtime}
	\begin{tabular}[t]{ l c c }
			 \toprule
    									 		&Generate Proof (ms)	&		Verification  (ms)\\ \midrule		
  			Bulletproof s  				&   $ 198$   & $ 79$ 	\\
    			Signature-based 		&   $ 240 $   				&	$438$  \\
    			Set Membership 		&		$66$				&	$90$	\\
			\bottomrule		
	\end{tabular}
 \end{table}

 In Table \ref{tab:runtime} it is clear that the signature based range proof is much slower than Bulletproofs, especially  in the verification algorithm. In  applications with many clients the verification runtime  is important since a verifier has to verify all clients. Bulletproofs has slightly faster runtime compared to Set memberships proofs in the verification algorithm, although their performance is still comparable and the set membership has he advantage that the runtime is indepenent of the size of the set, unlike Bulletproofs. This concludes that the Bulletproofs and set membership proofs are the best candidates found for combining with the VAHSS, in order  to verify the clients.
	
\section{Additive homomorphic secret sharing with verification of both clients and servers }
\label{sec:combination}

The VAHSS constructions  discussed in section \ref{sec:VAHSS} assumes honest clients and verifiers that the servers computations are correct. The aim of this paper is to extended the VAHSS construction to verify both client and servers, without the clients needing to reveal their secrets. 

Two methods for verifying clients honesty without revealing the secret values  are zero-knowledge range proofs and set membership proofs. If a range proof or set membership proof is included in the VAHSS construction then potentially malicious clients can only have limited influence on the computed sum. Range proofs and set membership proofs forces malicious input to still be part of the range or set. This leads to that the impact on the sum that a malicious client can have is bounded by the size of the range or the elements in the set. 

In this section it will be investigated how to combine the range proofs and set membership proofs, presented i section \ref{sec:RF_theory}, with the VAHSS construction presented in section \ref{sec:VAHSS}. Note that to ensure honest clients it is  not sufficient to construct and perform a range proof and VAHSS scheme separately. In such a protocol the verifier cannot be sure that the secret proven to be in the allowed range is the same as the secret hidden by the shares.

All considered range proofs and set membership proofs emanate from a Pedersen commitment hiding a secret and generates a zero knowledge proof that this secret belongs to an pre-specified interval or set. Besides this common feature the constructions of the presented range proofs and set membership proofs differ considerably. Therefore the possibility to exploit the Pedersen commitment in order to link the VAHSS construction with a range proof is investigated. More precisely a link between the shares hiding the secrets generated in the algorithm \textbf{ShareSecret} in the VAHSS construction and the secrets hidden in the Pedersen commitments used in the range proofs and set membership proofs is desired. Proving such a connection would convince the verifier that the shares represents a secrets that is in the allowed range.  

As discussed above, publishing a Pedersen commitment of the secret itself does not provide any guarantee that it is the same secret that is hidden in the shares. It can also be seen that committing to the shares in Pedersen commitments does not ensure the verifier that the secret hidden in the shares are in the allowed set or range. This is since the individual shares themselves does not reveal information about the secret they are hiding. This leads to that there is not guarantee that proving a share belongs to the allowed range (or set) implies that the secret does and the other way assuming that the secret to a range (or set) does not imply that the shares does. Thus some trick to connect the secret in the shares to the secret in the Pedersen commitment must be derived. Therefore  that the aggregation of the partial proofs used in the VAHSS construction to prove the honesty of the servers will be used to connect the range proofs to the VAHSS construction.

Recall that the clients in addition to the shares also publishes the checksum $\tau_i$ for the secret $x_i$, further recall that the definition of the checksum is  $\tau_i=g^{x_i+R_i}$, where $R_i$ is chosen uniformly at random from the field $\mathds{F}$.  Using this checksum as the Pedersen commitment in the construction of a range proof would be correct. However if $g=h$ the computationally binding property of a Pedersen commitment would not hold since $log_g(h)=log_g(g)=1$ which leads to that the left hand side in equation \eqref{eq:pedersen_binidng} is equal to $1$. Therefore to construct two commits $\mathds{E}(x,R)$ and $\mathds{E}(x',R')$ such that $\mathds{E}(x,R) = \mathds{E}(x',R')$ but $x\neq x'$ it is sufficient to solve solve for $x'$ in, 
\begin{align*}
1 = \frac{x-x'}{R-R'}\:mod \:N.
\end{align*}
In other words it is straightforward to create a false commitment hence also a false range proof and set membership proof.

Therefore it is instead investigated if the checksum $\tau_i$ can be modified into a Pedersen commitment. This leads to that instead of the previously computed checksum $\tau_i$,  the clients compute and output $\pi_i=g^{x_i}h^{R_i}$ , where $x_i,R_i,g,h$ are as above. Now a range proof can easily be constructed for the commitment $\pi_i$. Below it will be shown that Theorem \ref{thm:VAHSS_CSV} still hold after replacing $\tau_i$ with $\pi_i$. It remains to argue that this method ensures the verifier that the secret hidden by the shares is the same secret proven to be in the allowed range or set. 

Assume that client $c_k$ commits to the value $\hat{x}_k$ in the Pedersen commitment $\pi_k$ and constructs shares, $x_k_j$ such that $x_k = \sum_{j\in\mathcal{M}}x_{kj} \neq \hat{x}_k$. This leads to that $c_k$ generates a range proof that the secret hidden in the commitment belongs to the interval $[a,b]$ but the secret hidden by the shares does not necessarily belong to the range or set. Then the verification of the servers will not hold, since  $\prod_{i=1}^m \pi_i \neq g^y$. this means that the verification will return false and the protocol will not succeed, even if all  range proofs verifies true. Thus any cheating party will be detected, it will not be possible do determine which party that cheated and more precisely not even if the cheating party was a client or a server. 

In Construction \ref{alg:VAHSS-HSS-RP} the extended VAHSS, such that the construction ensures honest clients by including a range proof or set membership proof is described in detail. In order to clarify the modifications made to include a verification of the clients, the differences to the VAHSS construction presented in \cite{SumItUp} are pointed out. The algorithms \textbf{ShareSecret} and \textbf{Verify} has been modified,  and the algorithms \textbf{RangeProof} and \textbf{GenerateCommitment} have been added. More precisely in the algorithm \textbf{ShareSecret} does not output the checksum $\tau_i$, instead the Pedersen commitment $\pi_i$ is computed in the algorithm \textbf{GenerateCommitment}. The algorithm  \textbf{GenerateCommitment} can be included in either \textbf{ShareSecret}  or \textbf{RangeProof} instead of being viewed as a separate algorithm. In the implementation discussed later the commitment is generated while constructing the range proof and not explicitly. The algorithm \textbf{RangeProof} constructs a range proof (or set membership proof) denoted $RP_i$ given the commitment $\pi_i$. It is not specified which range proof or set membership proof that is used to verify clients.  Which range proof or set membership proof that is used does not affect the rest of Construction \ref{alg:VAHSS-HSS-RP}, as long as it emanate from a Pedersen commitment, hence it is left unspecified. In addition to the steps in the algorithm \textbf{Verify} in construction \ref{alg:VAHSS-HSS}, the algorithm \textbf{Verify} verifies the correctness of the range proof $RP_i$ and an additional \texttt{AND} operator to compute the total verification.  

The  algorithms \textbf{GenereateCommitment} and \textbf{RangeProof} are executed by the clients and the other algorithms are executed by the same party as in the  VAHSS construction in \cite{SumItUp}. 

%In the VAHSS Construction \ref{alg:VAHSS-HSS} the verifiability property includes verification of the servers. In this section this will be extended to also include the clients. The value $\pi_i$ published by the clients will be modified into a Pedersen commitment on the form $\pi_i = g^{x_i}h^{R_i}$, remember $\pi_i=g^{x_i+R_i}$ in the original construction presented in \cite{SumItUp}. The clients will apart from the previous commitments  also construct and publish a range proof for $\pi_i$. This allows any verifier to apart from verifying the servers also verify that the secret shared by the clients is in an certain range.  

%Given this construction the correctness, security and verification requirements for the server verifiable AHSS presented in \cite{SumItUp} is still fulfilled  that should be fulfilled is redefined below.  The difference to the requirements for the server verifiable AHSS is that additional demands for the clients behaviour is included. 

\begin{comment}
\begin{itemize}
    \item \textbf{Correctness} It must hold that Pr$\Big[\textbf{Verify}(\{\pi_i\}_{i\in\mathcal{N}},\sigma,y,\{RP_i\}_{i\in\mathcal{N}})=1\Big]=1$. This means that 					with probability $1$ the output $y$ from \textbf{FinalEval} is accepted given all parties (clients and servers) where honest and the protocol were executed correctly.
    \item \textbf{Security} 
    			\begin{itemize}
    						\item \textbf{Malicious Servers } The construction should satisfy the same security argument as the VAHSS-HSS construction in \cite{SumItUp}.
    						%Let $T$ define the set of corrupted servers such that $|T|<m$, i.e at 					least one server is honest.  										Denote a PPT adversary by $\mathcal{A}_1$ and let the Adv$(1^			\lambda,\mathcal{A},T):= \text{Pr}[b' = b]-1/2$ be the advantage 										of $\mathcal{A}=\{\mathcal{A}_1,\mathcal{D}\}$ in guessing $b$ in the following experiment:
    							%		\begin{enumerate}
       						%				 \item The adversary $\mathcal{A}_1$ gives $(i,x_i,x_i')$ to the challenger, where $i\in[n], x_i\neq x_i'$ and $|x_i|=|x_i'|$.
        						%				\item The challenger picks a bit $b\in\{0,1\}$ uniformly at random chooses and computes $\textbf{ShareSecret}(1^\lambda,i,																\hat{x}_i) = (\hat{\text{share}}_{i1},...,\hat{\text{share}}_{im},\tau_i)$, where $\hat{\textbf{x}}_i$ is  such that $\hat{x}_i = 																\begin{cases}x_i, \text{ if } b=0 \\ x_i' \text{ else} \end{cases}$. 
        					%					\item Given the shares from the corrupted servers T and $\hat{\tau}_i$ the adversary distinguisger outputs a guess 																			$b'\xleftarrow[]{}\mathcal{D}((\hat{\text{share}_{ij}})_{j|s_j\in T},\hat{\tau}_i)$.
   									% \end{enumerate}
    							%		A VAHSS-construction is $t$-secure if for all $T\subset \{s_1,...,s_m\}$ with $|T|<t$ it holds that Adv$(1^\lambda,\mathcal{A},T)<												\varepsilon(\lambda)$ for some negligible $\varepsilon(\lambda)$.
  					  \item \textbf{Malicious Clients}  Since the construction does not clarify the exact range proof used, the security argument is refereed to the original papers for the used range proof and by proving that the secret hidden by the Pedersen commitments is the same as the secrets in the shares. 
   		 \end{itemize} 
 	\item \textbf{Verifiability} 
 			\begin{itemize}
 						\item \textbf{Verify Servers }Let $\mathcal{A}$ denote any PPT  adversary and $T$ denote the set of corrupted servers with $T\leq m$. The verifiability 							property requires that any $\mathcal{A}$ who can modify the input shares to all servers $s_j\in T$ can cause a wrong value to be excepted as 							$y=f(x_1,...,x_n)$ with negligible probability.   
 						\item \textbf{Verify Clients} Let $\mathcal{A}$ denote any PPT adversary and $T$ denote the set of corrupted clients. The verifiability property requires that any $\mathcal{A}$ who can modify the Pedersen commitments $\pi_i$  to any $\pi_i^{'} \:\forall  i\in T$ has a negligible probability at choosing a commitment $\pi_i^{'}$ such that Verify$( \{\pi^{'}_i\}_{i\in\mathcal{N}},x,y)=1$.
 			\end{itemize} 
\end{itemize}
\end{comment}

\begin{algorithm}
\caption{\textbf{: Client and Server Verifiable additive homomorphic secret sharing}}

\textbf{Goal:} Construct and share the sum $\sum_{i=1}^n x_i$, where $x_i$ is a secret value known by client $c_i$, where $i\in\mathcal{N}$ without any client needing to revealing their individual secret. All parties are verified to be honest in the construction.
\vspace{2pt}
\hline
\vspace{2pt}
\begin{itemize}
 \item\textbf{ShareSecret $(1^\lambda,i,x_i) \mapsto \{x_{ij}\}_{j\in\mathcal{M}}$} \\
Pick uniformly at random $\{a_i\}_{i\in\{1,..,t\}}\in_R\mathds{F}$ to be the coefficients to a $t$-degree polynomial $p_i$ on the form $p_i(X) = x_i + a_1X+...+a_tX^t$. Define  the shares as $x_{ij}=\lambda_{i,j}p_i(\theta_{ij})$ for $j\in\mathcal{M}$, the parameters $\theta_{ij}$ and Lagrange coefficients $\lambda_{ij}$ is chosen such that equation \ref{eq:pi(0)} is satisfied.
Output $\{x_{ij}\}_{j\in\mathcal{M}}$.

\item\textbf{GenereteCommitment$(1^\lambda,i,x_i) \mapsto \pi_i$ }\\
Let $\mathds{E} : x,y \to g^xh^y$ be a Pedersen commitment . Let $R_i\in\mathds{F}$ be the output of a PRF such that $R_n\in \mathds{F}$  satisfies $R_n = \phi(N)\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N)}\rceil- \sum_{i=1}^{n-1}R_i $. Compute and output $\pi_i = \mathds{E}(x_i,R_i)$.

\item\textbf{RangeProof $(x_i,\pi_i) \mapsto RP_i$}\\
Construct a range proof, denoted $RP_i$, for the commitment $\pi_i$ to the secret $x_i$, on the  range $[0,B]$ ( or a set $\Phi$) using Construction \ref{alg:ZKSM}, \ref{alg:ZKRP} or \ref{alg:bullet}. All required  parameters and setup is assumed to be pre-shared and known by all parties.
\item\textbf{PartialEval $(j,\{x_{ij}\}_{i\in\mathcal{N}})\xrightarrow[]{}y_j$}\\
Compute and output $y_j = \sum_{i=1}^n x_{ij}$.

\item\textbf{PartialProof $(j,\{x_{ij}\}_{i\in\mathcal{N}})\xrightarrow[]{}\sigma_j$}\\
Compute and output $\sigma_j = \prod_{i=1}^n g^{x_{ij}} =  g^{\sum_{i=1}^n x_{ij}}= g^{y_j}=H(y_j)$.

\item\textbf{FinalEval $(\{y_j\}_{j\in\mathcal{M}})\xrightarrow[]{}y$}\\
Compute and output $y = \sum_{j=1}^m y_{j}$.

\item\textbf{FinalProof $(\{\sigma_j\}_{j\in\mathcal{M}})\xrightarrow[]{}\sigma$}\\
Compute and output $\sigma = \prod_{j=1}^m \sigma_j = \prod_{j=1}^m g^{y_{j}} =  g^{\sum_{j=1}^m y_{j}}= g^{y}=H(y)$.

\item\textbf{Verify $(\{\pi_i\}_{i\in\mathcal{N}},x,y,\{RP_i\}_{i\in\mathcal{N}})\xrightarrow[]{}\{0,1\}$}\\
Compute and output $\sigma= \prod_{i=1}^n \pi_i \wedge \prod_{i=1}^n \pi_i = H(y)\wedge \{\textbf{Verify}_{rp}(RP_i)\}_{i\in\mathcal{N}}$. Where $\textbf{Verify}_{rp}$ is the verification algorithm associated with the algorithm used by the clients to construct the range proofs, $\{RP_i\}_{i\in\mathcal{N}}$.
\end{itemize}
\label{alg:VAHSS-HSS-RP}
\end{algorithm}

\begin{thm}
\label{thm:VAHSS_RP_CSV}
\vspace{10pt}
The client and server verifiable AHSS presented in Construction \ref{alg:VAHSS-HSS-RP} satisfies the correctness, security and verifiability requirements described in section \ref{sec:VAHSS}, by replacing $\tau_i$ with $\pi_i$. Additionally it also satisfies the following extension of the verification requirement:

Let $\mathcal{A}$ denote any PPT adversary and $T$ denote the set of corrupted clients. The extended verifiability property requires that any $\mathcal{A}$ who can modify the Pedersen commitments $\pi_i$  to any $\pi_i^{'} \:\forall  i\in T$ has a negligible probability at choosing a commitment $\pi_i^{'}$ such that Verify$( \{\pi^{'}_i\}_{i\in\mathcal{N}},x,y,\{RP_i\}_{i\in\mathcal{N}})=1$.



%\begin{itemize}
 %\item \textbf{Verifiability Servers}  Let $\mathcal{A}$ denote any PPT  adversary and $T$ denote the set of corrupted servers with $T\leq m$. Note that if $|T|=m$, the verifiability property holds but not the security property. The verifiability property requires that any $\mathcal{A}$ who can modify the input shares to all servers $s_j\in T$ can cause a wrong value to be excepted as $y=f(x_1,...,x_n)$ with negligible probability.  
 %\item  \textbf{Verifiability Clients} 
%\end{itemize} 

\end{thm}
%TODO fix proof before hand in to Seminar 2
\begin{proof}
To argue that that the correctness, security and verifiability properties for the server verifiable AHSS still holds after replacing  $\tau_i$ with $\pi_i$ for $i=1,...,n$, it is noted that,
\begin{align*}
&\prod_{i=1}^n \pi_i = \prod_{i=1}^n g^{x_i}h^{R_i} = g^{\sum_{i=1}^n x_i}h^{\sum_{i=1}^n R_i} = g^{\sum_{i=1}^n} h^{ \phi(N)\big\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N) }\big\rceil} = g^y \\
&\text{Hence it follows that: } \prod_{i=1}^n \tau_i = \prod_{i=1}^n \pi_i.
\end{align*}
Further the Pedersen commitment is perfectly hiding and computationally binding and hence it follows that the requirements is still fulfilled. 

It remains to prove that Construction \ref{alg:VAHSS-HSS-RP} also fulfils the extended verification requirement. This follows from the soundness of the range proofs or set membership proof used in the construction and by the argument above that the secret hidden in the commitment $\pi_i$ must be the same as the secret obtain by combining the the shares $\{x_{ij}\}_{j\in\mathcal{M}}$ for all $i=1,...,n$.

\begin{comment}
The correctness follows from the correctness of range proofs and by proving that $\sigma= \prod_{i=1}^n \pi_i \:\bigwedge\: \prod_{i=1}^n \pi_i = \mathcal{H}(y)$. Both $y$ and $\sigma$ are the same as in Construction \ref{alg:VAHSS-HSS}, hence by construction:
\begin{align}
    \label{eq:y=sum(x_ij)}
    y = \sum_{j=1}^m y_j= \sum_{j=1}^m \sum_{i=1}^n \lambda_{ij}p_i(\theta_{ij}) = \sum_{i=1}^n \overbrace{ \Big (\sum_{j=1}^m \lambda_{ij}p_i(\theta_{ij}) \Big)}^{ p_i(0)} = \sum_{i=1}^n p_i(0) = \sum_{i=1}^n x_i,
\end{align}
and for $\sigma$ it holds that:
\begin{align*}
    \sigma = \prod_{j=1}^m \sigma_j = \prod_{j=1}^m g^{y_j} = g^{\sum_{j=1}^my_j} =g^y = \mathcal{H}(y)
\end{align*}
For the $\pi_i$, whose construction has been modified compared to $\tau_i$ in  Construction\ref{alg:VAHSS-HSS}, thus it follows that:
\begin{align*}
    &\prod_{i=1}^n \pi_i = \prod_{i=1}^n \mathds{E}(x_i,R_i)= \prod_{i=1}^n g^{x_i}h^{R_i} = g^{\sum_{i=1}^n x_i } h^{\sum_{i=1}^n R_i} \overset{\eqref{eq:y=sum(x_ij)}}{=} g^y h^{\sum_{i=1}^{n-1} R_i+R_n} = \\ 
    &= g^y h^{ \phi(N)\big\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N) }\big\rceil} = g^y = \mathcal{H}(y) 
\end{align*}

The proof of security argument for malicious servers given in \cite{SumItUp} is still sufficient since the Pedersen commitment is perfectly hiding and computationally binding and that the range proofs are zero knowledge. The security argument for malicious clients follows from the soundness of the range proof and that the secret hidden in the commitment has to be the same as the secret in the shares, as argued above. . 

The proof of \textit{\textbf{Verifiability Severs}} is the same as the proof given in  in \cite{SumItUp}, except that the commitments $\pi_i$ replaces the checksums $\tau_i$.  \textit{\textbf{Verifiability Clients}} follows from the properties of the range proof.
\end{comment}
\end{proof}


\section{Improving runtime}
\label{sec:aggregation}
A desired property for the above presented server and clients verifiable AHSS would be to aggregate the range proofs into one, since then the verifier would have to perform one range proof verification instead of one for each client as in Construction \ref{alg:VAHSS-HSS-RP}. This would decrease the runtime for the verification significantly, especially in implementations where many clients participate. Aggregating the range proofs would require the proofs to be homomorphic, such that the verification remains valid also for an aggregated proof.

A small remark is that the naive approach to aggregate the commitments $\pi_i, \: i\in\mathcal{N}$ to $\pi = \prod_{i=1}^n \pi_i$. Then construct a range proof for the aggregated commitment $\pi = g^{\sum_{i=1}^n x_i}$ is in the range $[n\cdot a,n\cdot b]$, to prove $x_i \in [a,b]$ for all $i \in\mathcal{N}$  does not satisfy the verification property in Theorem \ref{thm:VAHSS_RP_CSV}. The value $y=\sum_{i=1}^n x_i$ is publicly known so to construct a zero knowledge range proof for $y $ provides no new information and given that $y\in [n\cdot a,n\cdot b]$ does not imply $x_i\in [a,b]$ for all $i\in\mathcal{N}$. 

\subsection*{Aggregating Set membership proof}
In this section the possibility to aggregate the set membership and signature based range proofs  is examined.  The construction of these two are similar and it is sufficient to consider one of them, due to  its simpler notation the set membership proof is considered. Consider two range proofs $RP_1$ and $RP_2$ generated by the algorithm \textbf{Prove} in construction \ref{alg:ZKSM}, recall that such set membership proofs are on the form $RP_i = (V_i,a_i,D_i,z_{x_i},z_{\tau _i},z_{R_i}, )$ for $i=1,2$ and that a proof verifies true if  $D=C_i^{c_i}h^{z_{R_i}}g^{z_{x_i}}\wedge a_i = e(V_i,y)^ce(V_i,g)^{z_{x_i}}e(g,g)^{z_{\tau_i}}$. In addition to knowledge of the proof the verifier also has knowledge of the commitment $C_i$ published by the clients, group elements $h,g$  and the challenge $c_i$ can be computed by the verifier. To aggregate the proof each element building the proof would need to be aggregated such that the verification of the aggregated proof can be carried out in the same way as before. First test the straight forward aggregation hence let $RP = (V,a,D,z_{x},z_{\tau },z_{R})$ be the aggregated range proof and  where $V, a, D,z_{x},z_{\tau },z_{R}$ be defined as,
\begin{equation}
\begin{aligned}
\label{eq:naiveAgg}
V =& V_1V_2 = g^{\frac{\tau_1}{\chi + x_1}}g^{\frac{\tau_2}{\chi + x_2}}  = g^{\frac{\tau_1}{\chi + x_1} + \frac{\tau_2}{\chi + x_2}}  \\
a =& a_1a_2 = \big(e(V_1,g)^{-s_1})e(g,g)^{t_1}\big)  \big(e(V_2,g)^{-s_2})e(g,g)^{t_2}\big) \\
=&  \big( e(g,g)^{\frac{-s_1\tau_i}{\chi+x_1}}e(g,g)^{t_1}\big) \big( e(g,g)^{\frac{-s_2\tau_2}{\chi+x_2}}e(g,g)^{t_2}\big) \\
D =& D_1D_2 = ( g^{s_1}h^{m_1} ) (g^{s_2} h^{m_2}) = g^{s_1+s_2}h^{m_1+m_2}\\
z_x =& z_{x_1} + z_{x_2} = (s_1-c_1x_1)+(s_2-c_2x_2)\\
z_R =& z_{R_1} + z_{R_2} = (m_1-c_1R_1)+(m_2-c_2R_2)\\
z_\tau =& z_{x_1} + z_{x_2} = (t_1-c_1\tau_1)+(t_2-c_2\tau_2)\\ 
\end{aligned} 
\end{equation}
%are the multiplication of the corresponding elements in the two non aggregated range proofs and are the addition of the corresponding elements in the two non aggregated range proofs. To clarify two examples are, $D=D_1*D_2 =g^{s_1}h^{m_1}*g^{s_2}h^{m_2} = g^{s_1+s_2}h^{m_1+m_2}$, and the two exponentials are now refereed to as $s,m$, more over $z_x = z_{x_1}+z_{x_2} = (s_1-x_1c_1 )+ (s_2-x_2c_2) = s- x_1c_1-x_2c_2 $.
Further also calculate the challenges $c_1$ and $c_2$ according to $c_i=Hash(a_i,D_i),\: i=1,2$ and remember that the  commitments $C_i$  are homomorphic, which follows directly from the homomorphic properties of the Pedersen commitment. It is less obvious to see that the bilinear map can be aggregated, but this has been shown and the security proven in \cite{aggregate_bm}. However the homomorphic properties of the Pedersen commitment and bilinear maps does not guarantee that the range proofs is homomorphic. 


%But although bilinear maps can be aggregated it turns out that the set membership proof does not have this property, this follows from design of $z_x,z_\tau $ and $z_R$ using addition and subtraction, when multiplying two sums the cross-terms will not cancel as desired, this is seen below. 

Next it will be investigated if the aggregated proof $RP$ verifies true given all parties were honest, i.e see if the completeness property holds after aggregation. For the verification to succeed it must hold that, $1)$ $D\overset{?}{=} C^ch^{z_R}g^{z_x}$ and $2)$ $ a \overset{?}{=} e(V,y)^ce(V,g)^{-z_x}e(g,g)^{z_\tau}$,  hence check if it holds starting with the first.

\begin{align*}
LHS &= D = D_1*D_2 = g^{s_1+s_2}*h^{m_1+m_2} \\
RHS &= C^ch^{z_R}g^{z_x} = (C_1*C_2)^{c_1c_2}h^{z_{R_1}+z_{R_2}}g^{z_{x_1}+z_{x_2}} \\ 
&=(g^{x_1}h^{R_1}g^{x_2}h^{R_2}) ^{c_1c_2}  h^{m_1-R_1c_1+m_2-R_2c_2} g^{s_1- x_1c_1+s_2-x_2c_2} \\
&= g^{c_1c_1(x_1+x_2)+s_1+s_2-x_1c_1-x_2c_2}h^{c_1c_2(R_1+R_2)+m-R_1c_1-R_2c_2} \\
\implies \text{LHS}\neq \text{RHS}.
\end{align*}
The equality does not hold due to the $ c_1c_2(x_1+x_2) = c_1c_2x_1+c_1c_2x_2 \neq x_1c_1 + x_2c_2$ and hence the terms does not cancel and the RHS is dependent of $x_1,x_2,c_1,c_2$ unlike the LHS. Further note that if $c_1=c_2$ then this would be easy to fix. Clearly it cannot be guaranteed that the two challenges will be equal since they depend on randomness in the proof construction. This leads to that a more cleaver aggregation that circumvent this issue is needed. Again consider the two range proofs $RP_1,RP_2$ as defined above, but for now only the first equality $D\overset{?}{=} C^ch^{z_R}g^{z_x}$ in the verification is of interest. Remark is that if only half the verification is aggregated it still lead to important reduce of computations for the verifier. The goal is now to combine the two range proofs into one aggregated proof  that fulfils first equality. Before aggregation calculate the challenges $c_1,c_1$ as $c_i =Hash(D_i,a_i),\:i=1,2$. Then define the new aggregated range proof  $RP' =(D,z_x,z_R)$, since only the first equality is concerned, for now, the proof does not contain the bilinear map $a$ and the group element $V, z_{\tau}$. Further the aggregated proof is defined as, 
\begin{equation}
\label{eq:aggD2}
\begin{aligned}
D &= D_1^{c_2}\cdot D_2^{c_1} = (g^{s_1}h^{m_1}) ^{c_2} \cdot (g^{s_2}h^{m_2}) ^{c_1}  =g^{s_1c_2+s_2c_1}h^{m_1c_2+m_2c_1} \\
z_x &= c_2z_{x_1} +c_1 z_{x_2} = c_2(s_1-x_1c_1)  + c_1(s_2-x_2c_2) = s_1c_2 + s_2c_1 -c_1c_2(x_1+x_2)\\
z_R &= c_2z_{R_1} +c_1 z_{R_2} = c_2(m_1-R_1c_1)  + c_1(m_2-R_2c_2) = m_1c_2 + m_2c_1 -c_1c_2(R_1+R_2)
\end{aligned}
\end{equation}
Additionally also define the aggregated challenge and commitment as,
\begin{align*}
c &= c_1c_2 \\
C &= C_1C_2 = (g^{x_1}h^{R_1}) (g^{x_2}h^{R_2}) = g^{x_1+x_2}h^{R_1+R_2}= g^{x_1+x_2}.
\end{align*}
It is assumed that the random values $R_i$ is chosen such that $R_n = \phi(N)\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N)}\rceil- \sum_{i=1}^{n-1}R_i $, which holds for the randomness in a VHASS construction, hence for $i=1,2$ if follows that $R_2 = \phi(N)\lceil \frac{R_1}{\phi(N)}\rceil- R_1$, and thus $h^{c_1c_2(R_1+R_2)} = 1$. This property will not be required for the below calculations, however is does reduce notation and therefore the computations are done under this assumption. 
Using this aggregation to construct the aggregated proof, $RP$, when evaluate if $D\overset{?}{=} C^ch^{z_R}g^{z_x}$ it holds that,
\begin{align*}
LHS &= D = D_1^{c_2}\cdot D_2^{c_1} =g^{s_1c_2+s_2c_1}h^{m_1c_2+m_2c_1} \\
RHS &= C^ch^{z_R}g^{z_x} = (C_1C_2)^{c_1c_2}h^{c_2z_{R_1}+c_1z_{R_2}}g^{c_2z_{x_1}+c_1z_{x_2}}\\ 
&=(g^{x_1 + x_2})^{c_1c_2} h^{m_1c_2 +m_2c_1} g^{s_1c_2+ s_2c_1- c_1c_2(x_1+x_2)}  \\
&= g^{(x_1+x_2)c_1c_2 - c_1c_2(x_1+x_2) +s_1c_2+s_2c_1} h^{m_1c_2 +m_2c_1} = g^{s_1c_2+s_2c_1} h^{m_1c_2 +m_2c_1} \\
\\ \implies \text{LHS} =\text{RHS}&.
\end{align*}
This means that this aggregation to construct the proof $RP$ , from the two range proofs $RP_1,RP_2$ as above satisfies the first equality of the verification. Next it will be tested if this can aggregation can be extended to an aggregate arbitrary number of range proofs. Consider $|\mathcal{S}|$ clients, $c_i\:i\in\mathcal{S}$, and $|\mathcal{S}|$ range proofs denoted $RP_i,\: i\in\mathcal{S}$. The aggregation in equation \eqref{eq:aggD2} written for $|\mathcal{S}|$ proofs is then,
\begin{equation}
\label{eq:aggDn}
\begin{aligned}
D &=\prod_{i\in\mathcal{S}}  D_i ^{\prod_{\substack{j\in\mathcal{S}\\ j\neq i}} c_j }  =  \prod_{i\in\mathcal{S}}  (g^{s_i}h^{m_i}) ^{\prod_{\substack{j\in\mathcal{S}\\ j\neq i}}  c_j } = g ^ {\sum_{i\in\mathcal{S}} \Big(\prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)s_i} h^ {\sum_{i\in\mathcal{S}} \Big(\prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)m_i} \\
z_x &= \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}} c_j \Big) z_{x_i} = \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}} c_j \Big)s_i - \big( \prod_{j\in\mathcal{S}} c_j \Big) \sum_{i\in\mathcal{S}} x_i\\
z_R &=  \sum_{i\in\mathcal{S}}  \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}} c_j \Big) z_{R_i} = \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}} c_j \Big)m_i - \big( \prod_{j\in\mathcal{S}} c_j \Big) \sum_{i\in\mathcal{S}} R_i 
\end{aligned}
\end{equation}
Let $c=\prod_{i\in\mathcal{S}} c_i$ be the product of all challenges and $C= \prod_{i\in\mathcal{S}} C_i$ the product of the commitments.  Then define the aggregated range proof $RP = (D,z_x,z_r)$ aggregated according to equation \ref{eq:aggDn} and examine if it holds $D\overset{?}{=} C^ch^{z_R}g^{z_x}$, 
\begin{align*}
LHS =& D = g ^ {\sum_{i\in\mathcal{S}} \Big(\prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)s_i} h^ {\sum_{i\in\mathcal{S}} \Big(\prod_{\substack{j\in\mathcal{S}\\ j\neq i}}    c_j \Big)m_i}  \\
RHS =& C^ch^{z_R}g^{z_x} =  \Big( \prod_{i\in\mathcal{S}} C_i \Big)^{\prod_{i\in\mathcal{S}} c_i}h^ {\sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)m_i}\\
&g^{ \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)s_i - \big( \prod_{j\in\mathcal{S}} c_j \Big) \sum_{i\in\mathcal{S}} x_i}\\ 
 =& \Big( g^{\sum_{i\in\mathcal{S}} x_i} \Big)^{\prod_{i\in\mathcal{S}} c_i}h^{\sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)m_i} g^{ \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)s_i - \big( \prod_{j\in\mathcal{S}} c_j \Big) \sum_{i\in\mathcal{S}} x_i} \\
 =&  g^{ \sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}  c_j \Big)s_i } h^{\sum_{i\in\mathcal{S}} \Big( \prod_{\substack{j\in\mathcal{S}\\ j\neq i}}   c_j \Big)m_i}  
\\ \implies \text{LHS} =& \text{ RHS}.
\end{align*}

%TODO who aggregates, how do you ensure the aggregation is correct, challanges not possible for the verifier to compute since do not know the D_i and a_i and so on. Could you have a homoporphic hashfunction so this is not an issue? Or not since Di^{\prod{c_j}}... 

%TODO cleatify who does who and how the new verification would look. Could servers do it? Or would they then be able to indluence to their favour ? 

%TODO 1) assume aggregation correct, can client cheat? 
% 2) can aggregation be done not correct?
Above it has been seen that set memberships proofs can be aggregated according to equation \eqref{eq:aggDn} such that $D=C^ch^{z_R}g^{z_x}$, i.e this equality is checked once instead of once for each client. Given this, it is of interest to examine the possibilities to construct a aggregation such that multiple set membership proofs can be combined into one single proof, verifying all individual proofs by performing one verification. Hence it has to also hold that  $a \overset{?}{=} e(V,y)^c e(V,g)^{-z_x}e(g,g)^{z_\tau}$, where $a,V,z_{x},z_\tau$  are obtained by aggregating multiple set membership proofs. First it is tested if aggregation according to equation \eqref{eq:naiveAgg}, under the assumption $c_1=c_2$ is sufficient to satisfy this. If the equality would be satisfied then the same trick as above, namely aggregating such that the challenges appear only as a product, would yield a method for fully aggregating set membership proofs.  After some calculation, see Appendix \ref{appendix:aggregate_a} for the details of the calculations, it is realised that the terms,
\begin{align*}
e(V_1,g)^{z_{x_2}}e(V_2,g)^{z_{x_1}} = e(g,g)^{\frac{\tau_1}{\chi + x_1}(-s_2+x_2c) +\frac{\tau_2}{\chi + x_2}(-s_1+x_1c)   } ,
\end{align*}
on the right side of the equality are not cancelled. This concludes that even if $c_1=c_2$ the verification will not hold after aggregating according to equation \eqref{eq:naiveAgg}. This implies that in order to aggregate the whole set membership proof additional tricks are required. Several attempts to construct an aggregation that will cancel these terms, whichout introducing new terms, has been made without any success. Therefore whether it can be done or not is left unanswered. What can be seen as an indicator to that it is not be possible is that in the algorithm \textbf{Verify} in Construction \ref{alg:ZKRP}, the bilinear mappings are checked separately for each $j\in\mathds{Z}_l$. 
%A hint can also be seen in Construction \ref{alg:ZKRP} where the verification of first equity is aggregated while the second is done for each $j\in\mathds{Z}_l$. 



%Assuming that the 

%Argument security of aggregation 
The above discussion about possibilities to aggregate multiple set memberships proofs to reduce the computational complexity in applications where many proofs are verified simultaneously,  ended in a method for partly aggregating the proofs. This modified version of the set membership proof, originally presented in \cite{Efficient_proof_interval}, is presented in Construction \ref{alg:ZKSM-Agg}. The algorithm \textbf{Prove} in the aggregated set membership proof is run by all proving parties wanting to prove that their secret is in the set. Then the aggregating party takes all the set membership proofs as input and outputs an aggregated proof. The verifier takes the aggregated proof as input, and hence the equality check $D \overset{?}{=}( \prod_{i=1}^n C_i )^{c}h^{z_R}g^{z_x}$ is done once instead of once for each proving party in the protocol. 

In Construction \ref{alg:ZKSM-Agg} the challenges are given as input to the verifier, unlike the original set membership proof where the verifier calculates the challenge $c_i=Hash(a_i,D_i)$. The reason for this is that the values $D_i$ is not known to the verifier in the aggregated set membership proof. This raises the question about which party that should be responsible for calculating the challenges.  It is not desired that the party performing the aggregation also computes the challenger since this opens up for cheating, for the same reason should the proving party not compute the challenge. Thus, the challenges are computed by a different party, independent of both the proving-parties and the aggregating party, and finally multiplied together by the verifier. Another possibility is to include the values $\{D_i\}_{i\in\mathcal{S}}$ as input to the verification, leading to that the verifying party can compute the challenges, however this leads more computation needed in the verification.

%Comparing the algorithm \textbf{VerifyAggregatedProof} with performing the algorithm \textbf{Verify} in set membership construction once for each clients, it is seen that the first equality check $D \overset{?}{=}( \prod_{i=1}^n C_i )^{c}h^{z_R}g^{z_x}$ is done once instead of once for $|\mathcal{S}|$ times. Construction \ref{alg:ZKSM-Agg} presents all algorithms ,  \textbf{Prove}, \textbf{Aggregate}, \textbf{CalulateChallenges} and \textbf{VerifyAggregatedProof}, needed to build the aggregated set membership proof. 



% , that verifier all individual set membership proof by performing only one verification, resulted in a that a method for aggregating parts of the set membership proof. This method is compiled in Construction \ref{alg:ZKSM-Agg}, where the set membership proof originally presented in \cite{Efficient_proof_interval} is modified to reduce the computational complexity in applications where multiple  proofs are verified simultaneously.

%This leads to that a verification algorithm for verifying the aggregated version of set membership proofs $RP_i$ for $i\in\mathcal{S}$ to be as the algorithm \textbf{VerifyAggregatedProof} in Construction \ref{alg:ZKSM-Agg}.  %TODO 
%\begin{itemize}
%\item\text{\textbf{VerifyAggregatedProof} $(g,h,\{C_i\}_{i\in\mathcal{S}},\{c_i\}_{i\in\mathcal{S}} ,\texit{proof}_{SM,a}) \xrightarrow[]{} \{0,1\}$} \\
%Compute the product of the challenges $c=\prod_{i\in\mathcal{S}} c_i$. Check if $D_a\overset{?}{=} \big( \prod_{i\in\mathcal{S}}C_i\big)^ch^{z_R_a}g^{z_x_a}\wedge a_i \overset{?}{=} e(V_i,y)^c_i e(V_i,g)^{-z_{x_i}}e(g,g)^{z_{\tau_i}}$ for all $i\in\mathcal{S}$. If the equalities holds the provers has convinced the verifier that $x_i\in\Phi$ for all $x_i$ such that $i\in\mathcal{S}$ return $1$ otherwise return $0$.
%\end{itemize}
 
\begin{algorithm}[]
\caption{\textbf{: Aggregation of non interactive set membership proof}}
\textbf{Goal:} Given the Pedersen commitments $C_i=g^{x_i} h^{R_i}$ and a set $\Phi$, prove that the secrets $x_i$ , for $i\in\mathcal{S}$, in the commitments belongs to the set $\Phi$ without revealing anything else about the secrets $x_i$.
\vspace{2pt} \hline \vspace{2pt}
\begin{itemize}
  \item\textbf{SetUp $(g,h,\Phi)\xrightarrow[]{}(y,\{A_{i}\}_{i\in\Phi})$}\\
Pick uniformly at random $\chi\in_R\mathds{F}$. Define $y=g^\chi$ and $A_i=g^{\frac{1}{\chi+i}} \:\forall i\in\Phi$, output $y$ and $\{A_i\}_{i\in\Phi}$.

\item\text{\textbf{Prove} $(g,h,C_i,\Phi)\xrightarrow[]{}\textit{ proof}_{SM,i}=(V_i,a_i,D_i,z_{x_i},z_{\tau_i},z_{R_i})$}\\
Pick uniformly at random $\tau_i\in_R\mathds{F}$, choose from the set $\{A_i\}$ the element $A_{x_i}$ and calculate $V=A_{x_i}^{\tau_i}$. Pick uniformly random three values $s_i,t_i,m_i\in_R\mathds{F}$. Put $a_i=e(V_i,g)^{-s_i}e(g,g)^{t_i}$ ($e(\cdot,\cdot)$ is a bilinear mapping as described above), $D=g^{s_i}h^{m_i}$, and $c=\text{Hash}(a_i,D_i)$. Finally compute $z_{x_i} = s_i-x_i c_i$, $z_{R_i} = m_i-R_ic_i$ and $z_{\tau_i}= t_i-\tau_i c_i$ then construct and publish $\textit{proof}_{SM,i} = (V_i,a_i,D_i,z_{x_i},z_{\tau_i},z_{R_i})$.

\item \text{\textbf{Aggregate} $(g,h, \{ \textit{proof}_{SM,i}\}_{i\in\mathcal{S}} \xrightarrow[]{} \texit{proof}_{SM,a}$} \\
Given a subset of range proofs  $\{ \textit{proof}_{SM,i}\}_{i\in\mathcal{S}}$ where $\mathcal{S}\subseteq \{1,...,n\}$. Aggregate the values $\{D_i \}_{i\in\mathcal{S} } \{ z_{x_i}\}_{i\in\mathcal{S} } \{ z_{r_i}\}_{i\in\mathcal{S} } \mapsto D_a,z_{x_a},z_{R_a}$ according to equation \eqref{eq:aggDn}. Then construct and publish the aggregated range proof $\texit{proof}_{SM,a} = (\{V_i\}_{i\in\mathcal{S} },\{a_i\}_{i\in\mathcal{S} },D_a,\{z_{x_i}\}_{i\in\mathcal{S} }, z_{x_a}, \{z_{\tau_i}\}_{i\in\mathcal{S} },z_{R_a})$.

\item \text{ \textbf{CalculateChallenges} $(\{D_i\}_{\in\mathcal{S}}, \{a_i\}_{i\in\mathcal{S}} ) \xrightarrow[]{} \{c_i\}_{i\in\mathcal{S}}$ }\\
Compute and output $c_i = Hash(a_i,D_i)$ for all $i\in\mathcal{S}$.

\item\text{\textbf{VerifyAggregatedProof} $(g,h,\{C_i\}_{i\in\mathcal{S}},\{c_i\}_{i\in\mathcal{S}} ,\texit{proof}_{SM,a}) \xrightarrow[]{} \{0,1\}$} \\
Compute the product of the challenges $c=\prod_{i\in\mathcal{S}} c_i$. Check if $D_a\overset{?}{=} \big( \prod_{i\in\mathcal{S}}C_i\big)^ch^{z_R_a}g^{z_x_a}\wedge a_i \overset{?}{=} e(V_i,y)^c_i e(V_i,g)^{-z_{x_i}}e(g,g)^{z_{\tau_i}}$ for all $i\in\mathcal{S}$. If the equalities holds the provers has convinced the verifier that $x_i\in\Phi$ for all $x_i$ such that $i\in\mathcal{S}$ return $1$ otherwise return $0$.
\end{itemize}
\label{alg:ZKSM-Agg}
\end{algorithm} 
 

\subsubsection*{Completeness, Soundness and Zero-knowledge}
This section will investigate if the proposed aggregated set membership proof presented in Construction \ref{alg:ZKSM-Agg}  fulfils the completeness, soundness and zero-knowledge requirements stated in Definition \ref{def:ZKP} under the  assumption that the aggregation has been done correct by a trusted party. 

Completeness follows from the argument above that it holds that $D\overset{?}{=}C^ch^{z_R}g^{z_x}$, given all parties where honest. It is also clear that multiplying and adding elements which perfectly hides the secret $x_i$, with other elements independent of the secret will not reveal any information about the secret, hence the zero-knowledge property holds. 

This leads to that it remains to see if the soundness property holds for Construction \ref{alg:ZKSM-Agg}. The equality check $D\overset{?}{=}C^ch^{z_R}g^{z_x}$ in the original set membership construction servers the purpose of ensuring the verifier that the secret hidden in the commitment $C$ is the same as the secret used to construct the value $z_x$. Hence this property need to be checked that it remains after the aggregation, i.e that the verifier can be sure that all secrets hidden in the commitments, are equal to the secrets used to compute the values $z_{x_i}$, in turn used in the aggregation to construct $z_x$. 
%TODO fix margin? 
Consider two set membership proofs, $RP_1$ and $RP_2$, computed by the algorithm \textbf{Prove} in construction \ref{alg:ZKSM-Agg} are aggregated into 
$RP= (\{V_1,V_2\},\{a_1,a_2\}, D,z_x,\{z_{x_1,}z_{x_2}\}, \{z_{\tau_1},z_{\tau_2}\}, z_R))$, according to algorithm \textbf{Aggregate} in construction \ref{alg:ZKSM-Agg}. Given this set up, it will be investigated if it can hold that: $D = (C_1C_2)^ch^{z_R}g^{z_x}}$, where $C_i = g^{x_i}h^{R_i}$ and $z_{x_i} = s_i-c_i\tilde{x}_i$ such that $x_i\neq \tilde{x}_i$ for $i$ equal to either $1$, $2$ or both. Consider the below equations,
\begin{align*}
LHS =& g^{s_1c_2+s_2c_1}h^{m_1c_2+m_2c_1}\\
RHS =& g^{c_1c_2(x_1+x_2)}h^{c_1c_2(R_1+R_2)} g^{ c_2(s_1-c_1\tilde{x}_1 ) + c_1(s_2-c_2\tilde{x}_2 ) } h^{ c_2(m_1-c_1\tilde{R}_1 ) + c_1(m_2-c_2\tilde{R}_2 ) }\\
=&  g^{ s_1c_2+ s_2c_1} h^{ m_1c_2+ m_2c_1 }g^{c_1c_2 (x_1+x_2) - c_1c_1 (\tilde{x}_1+ \tilde{x}_2)} h^{c_1c_2 (R_1+R_2) - c_1c_1 (\tilde{R}_1+ \tilde{R}_2)}.
\end{align*}
Under the assumption that the aggregation was done correctly, one of the following cases has to hold if $LHS=RHS$,
\begin{enumerate}
\item $x_1=\tilde{x}_1$ and $x_2=\tilde{x}_2$ 
\item $x_1= \tilde{x}_2$ and $x_2 = \tilde{x}_1$
\item $(x_1+x_2) = (\tilde{x}_1+\tilde{x}_2)\: \text{mod} \: \Phi(N)$
%\item $x_2 = modinv(x_1)$ and $\tilde{x}_2 = modinv(\tilde{x}_1)$
%\item $x_1 = -modinv(\tilde{x}_1)$ and $x_2 = -modinv(\tilde{x}_2)$ or  $x_1 = -modinv(\tilde{x}_2)$ and $x_2 = -modinv(\tilde{x}_1)$  WHY?
\end{enumerate}
The first case corresponds to honest clients while the second and third case corresponds to cheating clients. 
In the second case the clients are cheating, since they do not use the same secret in the commitments as in $z_{x_i}$. If this is considered in the context of using the aggregated set membership proof in combination to a VAHSS construction the sum $y$ calculated in the VAHSS construction evaluates to the same value in both case $1$ and $2$, and all used terms in the summation is proved to be in the set $\Phi$. So despite cheating clients the result from the protocol is unaffected. This is since a cheating party in case $2$ only achieves to having his secret being committed to by another clients, as he commits to this clients secret. For the VAHSS construction it is not of relevance who committed what as long as the sum is the same and all terms in the sum is verified to be in the set. The third case shows that if two clients collaborate it is possible for them to use to the secrets $x_1$ and $x_2$ in the Pedersen commitment while using two other secrets $\tilde{x}_1$ and $\tilde{x}_2$ such that the they satisfies the third case, then $D\overset{?}{=} ( \prod_{i=1}^2 C_i)^ch^{z_R}g^{z_x}$ holds true. Thereby using $\tilde{x}_1$ and $\tilde{x}_2$ for the remaining of the proof and if they belong to the set $\Phi$, the clients has successfully cheated, since they have ensured the verifier that the secrets $x_1$ and $x_2$ are in the set, by falsely proven that the secrets in $x_1,x_2$ are equal to $\tilde{x}_i,\tilde{x}_2$. Thus it has to be assumed that clients cannot communicate in order for the soundness property to  hold for the aggregated set membership. Under this assumption both case two and case three has a negligible probability of succeeding, since the probability of two clients committing to secrets that by chance satisfies either case two or three is sufficiently small. %TODO is it?

% c be partially aggregated by servers, not compleatly by aggregator of RP -> alll c_i used most be correct?

%More precisely it has to hold that a secret not in $\Phi$ satisfies the verification with a negligible property and additionally that the secret hidden in the commitments $C_i$ is the same as the secrets in $z_{x_i}$. 


%Neither the  second equality test including  bilinear mapping holds after aggregation, this equality will not hold even if the challenges are equal, i.e $c_1=c_2$ unlike the first.  This concludes that the neither set membership nor signature based range proof can be straight forward aggregated without modifications.  Challange in included on both sides, is this an issue? But not yout own challange on LHS?

\subsubsection*{Assumptions about Aggregation}
In the previous section it was assumed that the aggregation was done according to equation \eqref{eq:aggDn} by a trusted party. Under this assumption is was argued that if the proving parties cannot communicate then the correctness, soundness and zero-knowledge property holds for the aggregated set membership proof in Construction \ref{alg:ZKSM-Agg}. In this section it will be investigated if the trusted party assumption is necessary or if some weaker assumption is sufficient alternatively if the aggregation can be checked. It will be assumed that proving parties cannot communicate between themselves and that proving parties cannot communicate with the aggregating party. 

Note that since all input used to aggregate the proves are public, the aggregation can be done by anybody. Therefore an aggregation performed can always be checked if it is correct by performing the aggregation on one's own and then examine if the two aggregation are the same. To aggregate the set membership proofs is an expensive operations and hence arguments on an aggregations correctness without having to redo the aggregation would be useful.

%An important feature in the verification of the original set membership construction is that verifier can compute the challenge as the hash of parts of the proof and hence the prover cannot cheat and use some cleaver challenge that cancel terms or in some other way affects the proof. The proposed aggregation does not provide sufficient input to the verification algorithm for the verifier to compute the individual challenges and then their product used in the verification. Further the challenges are computed and used in the aggregation hence it is necessary to perform some assurance that it is the correct challenges used. 
Before looking into how the aggregation party might cheat and depart from the aggregation in equation \eqref{eq:aggDn}, it will be cleared out what values the aggregation party can affect and what requirements that has hold. The aggregation party need to provide values for the proof parameters $D,z_x,z_R$ such that $D=C^ch^{z_R}g^{z_x}$. The party performing the aggregation can not modify the values of the product of commitments, denoted $C$, nor the value of the product of the provers challenges, denoted $c$. Further it will be assumed that the if an  aggregating party can choose the values $D,z_x,z_R$ freely (not according to equation \eqref{eq:aggDn} ) and the equality above holds, the aggregating party has successfully cheated. 

An important feature in the original set membership construction is that the verifier uses the same value $z_x$ is used for the entire verification. In the aggregated set membership, an aggregated value $z_x$ is used to test if $D\overset{?}{=}C^ch^{z_R}g^{z_x}$ while non-aggregated values $z_{x_i}$ are used to verify $a_i=e(V_i,y)^ce(V_i,g)^{-z_x}e(g,g)^{z_{\tau_i}}$ for $i\in\mathcal{S}$. Thereby the same value is not used in the entire verification. This means that in the aggregated set membership the aggregated value $z_x$ has less claims that needs to be fulfilled in order for the verification to succeed. 

A second important distinction is that in the original set membership construction the value of the challenge used is not possible to know when construction $D,a$ since it is a function of these values. In the aggregated set membership the challenges depends on the values publicly known for the aggregating party. This leads to that this knowledge can be taken advantage of to cheat. This results in that besides having a party independent of the aggregation, possibly the verifier, computing the product of the challenges, it must also be verified that $D\neq C^c$, due to he argument below.

If it is not checked that $D \neq C^c$ the following would be possible to choose the values $D,z_x,z_R$ according to,
\begin{align*}
D =& \prod_{i=1}^n C_i ^{\prod_{i=1}^n c_i}	\\
z_x =& \phi(p)	\\
z_R =& \phi(p),	\\
\end{align*}
where $p$ is the prime underlying the field $\mathds{F}$. For the above choice of $D,z_x,z_R$ the equation, $D\overset{?}{=} \big(\prod_{i=1}^nC_i\big)^{\prod_{i=1}^n c_i} h^{z_R}g^{z_x}$ holds trivially true, independent of whether the commitment $C_i$ and the values $z_{x_i}$ hide the same secret for all $i=1,...,n$. Henceforth it will be assume that it is checked that $D \neq \big(\prod_{i=1}^nC_i\big)^{\prod_{i=1}^n c_i}$. 

This leads to that the aggregation party can only cheat if the variables $D,z_R,z_x$ be chosen such that $D \neq \big(\prod_{i=1}^nC_i\big)^{\prod_{i=1}^n c_i}$ and $LHS=RHS$ in the below equation system:
\begin{align*}
LHS =& D\\
RHS  =& \big(\prod_{i=1}^nC_i\big)^{\prod_{i=1}^n c_i} h^{z_R}g^{z_x} =
\big( g^{\sum_{i=1}^n x_i } h^{\sum_{i=1}^n R_i} \big) ^{\prod_{i=1}^n c_i}h^{z_R} g^{z_x} \\
=& \big( g^{ (  \prod_{i=1}^n c_i ) \sum_{i=1}^n x_i ) } h^{ ( \prod_{i=1}^n c_i ) \sum_{i=1}^n R_i ) } \big)h^{z_R} g^{z_x}.
\end{align*}

What is left to be investigated is if the aggregating party can cheat by exploiting the fact that the value $z_x$ in the above equation system, is not used in the verification of $a_i\overset{?}{=} e(V_i,y)^ce(V_i,g)^{-z_x}e(g,g)^{z_{\tau_i}}$. In practise this would mean that the value $z_x$ does not need to contain the values $x_i$ in its construction. 

In order to have equality between the left hand side and the right hand side, the terms derived from the commitments must be cancelled. The aggregating party does not know the secrets $x_i$ or the random values $R_i$ for any $i=1,..,n$. Consequently to cancel the terms it is argued  that aggregation must be done according to equation \eqref{eq:aggDn}. The argument is that in order to cancel the terms depending on the unknown sum of secrets, $x_i$, and random values, $R_i$, the values $z_{x_i}$ and $z_{R_i}$ must be used. These term can not be combined in a way that all cross terms are cancelled besides as in equation \ref{eq:aggDn}. Remark here that this is assumed and not proved, in other words the security of the aggregated set membership presented in Construction \ref{alg:ZKSM-Agg} is based on this assumption or alternatively as in the previous section the assumption that the aggregation is done by a trusted party.

When considering the aggregated set membership in combination to a VHASS construction the sum of secrets can be computed by any party after all servers has performed the algorithm \textbf{partialEval} and it is known that $h^{\sum_{i=1}^n R_i } =1 \: \text{mod}\:  \phi(N)$. This leads to that although the individual secrets are unknown, it is possible to cheat by using the fact that $y, h^{\sum{R_i}}$ are known. This is see below by choosing $D=C^{k+c}, z_R = k\phi (N)$ and $z_x = k y$, where $y= \sum_{i=1}^n$ and $k_R\in \mathds{F}$, it follows that, 
\begin{align*}
LHS =& D = C^{k+c}= \big( g^ { k \sum_{i=1}^n x_i } h^{ k  \sum_{i=1}^n R_i ) } \big)   \big( g^{ (  \prod_{i=1}^n c_i ) \sum_{i=1}^n x_i ) } h^{ ( \prod_{i=1}^n c_i ) \sum_{i=1}^n R_i ) } \big)   \\
LHS =& C^c h^{z_R}g^{z_x} = C^c h^{k \phi (N) } g^{k y} =  \big( g^{ (  \prod_{i=1}^n c_i ) \sum_{i=1}^n x_i ) } h^{ ( \prod_{i=1}^n c_i ) \sum_{i=1}^n R_i ) } \big) h^{k\phi (N)} g^{ky}\\
= &  \big( g^{ (  \prod_{i=1}^n c_i ) \sum_{i=1}^n x_i ) } h^{ ( \prod_{i=1}^n c_i ) \sum_{i=1}^n R_i ) } \big)g^ { k y} h^{ k  \phi(N)\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N)}\rceil ) }\\
& \implies LHS= RHS.
\end{align*}
If the sum of $\sum_{i=1}^n x_i$ and $\sum_{i=1}^nR_i$ where unknown then the aggregation party would have to choose the values $z_x$ and $z_R$ such that,
\begin{align*}
h^{z_R}g^{z_x} \overset{!}{=} g^{k\sum_{i=1}^n x_i }h^{k\sum_{i=1}^n R_i } = \Big( g^{k\sum_{i=1}^n R_i}h^{k\sum_{i=1}^n R_i}\Big)^k,
\end{align*}
which is the same as construction two equal Pedersen commitments, which is assumed to be impossible due to that the $log_g h$ is unknown. 

It has been seen that, when one party aggregates the set membership proofs for all clients in a server and client verifiable AHSS construction it is possible for this part to cheat such that aggregated proof verifies true without the statement in equation \eqref{eq:SM_statement} is true.

The argument above also provides a method to circumvent this issue. If instead of having one party that aggregates all set membership proofs multiple parties aggregates subsets of the proofs, it would not be possible to cheat. For the VAHSS construction this can be implemented by the server aggregate different subset of the clients range proofs. For example in the case of $100$ clients and $5$ servers, each server aggregates $20$ proofs according to Equation \eqref{eq:aggDn}. The value of the sum of any true subset of the secrets is unknown and likewise the sum of the randomness, hence any party aggregating a subset of all clients range proofs can not cheat as above, since it requires knowledge of the exponentials which are unknown. Given the aggregated range proofs generated by the servers, $5$ aggregated range proofs has to be verified, this leads to $5$ checks that the first equality holds and $100$ checks of the second. Thus the first equality only has to be checked $5$ times instead of $100$ which would be the case if the range proofs were not aggregated. 
The workflow is illustrated in in Figure \ref{fig:workflow}. %TODO more here 



 \begin{figure}[]
\caption{TODO}
\label{fig:workflow}
\includegraphics[width=\linewidth]{./figure/workflow_challanger.png}
\end{figure}
To conclude, if the aggregation is not assumed to be performed by a trusted party then  the characteristics of the VAHSS construction all set membership proof cannot be aggregated together, instead two or more subsets of the range proofs must be aggregated separately and then all such aggregated subsets of  proofs are verified by the verifier. 



%The arguments given for the assumptions of the aggregating party and arguments for the aggregated proof satisfying the completeness, soundness and zero knowledge  does not act as formal proofs, it should rather be seen an as motivations. therefore all potential attacks on aggregated set membership proof can not be deducted and before using it in practise further security checks need to be performed. 





\subsection*{Aggregating Bulletproofs}
 The original paper about Bulletproofs \cite{bulletProofs_theory} presents a method to aggregate Bulletproofs such that $n$ parties each having a Pedersen commitment $C_i,\: i=1,...,n$ can generate a single Bulletproof verifying that each commitment hides a secret in an allowed range. The presented approach only works if all parties uses the same challenge $c$ in the proof construction, this is achieved by introducing a dealer. During the constructions of the proofs when computing the challenges each client sends their proof of to this point to the dealer who aggregates the proofs and computes the challenges based on the aggregated proofs. For example, assume $n$ clients and denote their respective proofs with a subscript $i$, then to compute the challenges $y_i$ in construction \ref{alg:bullet} instead of each client computing $y_i = Hash(A_i,S_i)$, each client sends $A_i,S_i$ to the dealer who adds then homomorphically $A = \prod_{i=1}^n A_i, S = \prod_{i=1}^n S_i$ and the send back the challenge $y =Hash(A,S)$ to be use by all clients. This procedure is repeated for each challenge. 
 
 It is noted that although the Fiat-Shamir heuristic is used to generate the challenges the construction is interactive since communication between the dealer and the clients is required during the construction of the aggregated range proof. If this procedure was ignored and each client instead computed their own challenges via Fiat-Shamir heuristic and the proof where aggregated after they were fully constructed,  then the challenges would differ between parties and the verification fail. 

Concluding, it has been seen that the  Bulletproof can be aggregated with the cost on an  interactive construction, however this is not a desirable property for the the server and client verifiable AHSS. Investigation about whether this construction can be modified to be completely non-interactive has not been done and remains an open question.  

%This concludes that neither of the considered range proofs has be sucessfully fully aggregated aggregated  such that the verifier can perform one single verification instead of one for each client, at least not without some cost. Remark that this conclusion is not final and their may very well exist small or large modifications of the range proof that will allow them to be aggregated and still remaining non-interactive. The investigation of such modification is outside the scope of this paper but the reader is endorsed to explore this possibility. 

\section{Implementation}
To practically investigate the combining of the VAHSS construction \ref{alg:VAHSS-HSS} with a range proof, construction \ref{alg:VAHSS-HSS-RP} is implemented. %is provided written in Golang. 
%Remark that this construction is written without specifying which range proof that is used, and works for all different range proofs that provides a proof for a Pedersen commitment, which is true for all range proof discussed above.
 From the analysis of the range proofs given above it is clear that Bulletproofs is faster than signature-based range proof, however considering the aggregation possibility for signature based range proof these might still be competitive for combination with VAHSS.  All three constructions will hence be used to implement the client and server verifiable additive homomorphic secret sharing construction \ref{alg:VAHSS-HSS-RP}. 

Implementations of Bulletproofs, set membership proofs and signature based range proofs written in Golang (Go) are all available on Github \cite{Git:RP}, implementations of the VAHSS construction \ref{alg:VAHSS-HSS}, written in both python and C++, is available at Github \cite{Git:python_vahss} \cite{Git:C_vahss}.
Because the implementation of the range proofs, set membership proofs and the VAHSS construction is not written in the same programming languages one of the two following modifications needs to be done. The first alternative is to write a wrapper for either the Go code so that it can be interpreted by a C++ (or Python) compiler, or wrap the CC++ (or Python) code such that it can be interpreted by a Golang compiler. The second alternative is to translate either the Go implementations to C++ (or Python) or the other way around. 

The first alternative appears to be a simpler approach hence this is first tested. In 2016 \textit{cgo} was released which enables calling C functions from Go code. 
The Go command \textit{cgo} enables Go packages to call C code. TODO...

This lead to instead test the second alternative, that is translating  the Go implementations to C++ (or Python) or the other way around. Since the VAHSS construction is more straight forward and much shorter than the two range proofs and the set membership proof all together this direction was chosen and Construction \ref{alg:VAHSS-HSS} was translated to Go.

Besides translating the VAHSS implementations to Go a small adjustments of the already existing Go implementations of the range proofs and set membership proof  had to be done to merge with the VAHSS construction. This adjustment are merely to merge the codes and does not change the semantics of the range proofs. What has been  modified is that the randomness used in the Pedersen commitments in the range proof must be chosen such that $R_n = \phi(N)\lceil \frac{\sum_{i=1}^{n-1}R_i}{\phi(N)}\rceil- \sum_{i=1}^{n-1}R_i$, hence is is regarded as input to the proof constructions.The full code for combination of range proofs (or set membership proofs) and VAHSS is available at Git \ref{Git:MyCode}. 

Just as in construction \ref{alg:VAHSS-HSS-RP} the implementation of the code aims to be  general, such that all three concerned range proofs can be used to verify clients honesty and the merge of the range proof to the VAHSS construction is the same for all range proofs. However note that although the construction does not specify which range proof that is used the implementation does due o the choice of underlying group in the set up, the signature-based range proofs and set membership proof uses pairing friendly elliptic curve groups in the implementation which is not the case for Bulletproofs. This leads to minor modifications of the implementation to adapt to range proofs and set membership proofs.

Specify what parameters that has been used for the implementation. The number of servers is set to $5$ and the number of clients to $100$.  The range is set to $[18,200]$ for both range proof implementations. This leads to that the parameter $n$ in the Bulletproof construction determining the complexity must be atleast $8$ since $2^8>200$, to keep runtime low it is put equal to eight and for the signature-based range proof, having fixed $u=57$ it is found sufficient to put $l=2$. To make the set membership implementation comparable the size of the set is equal to the length of the range , i.e $|\Phi|=200-18 = 182$.

 For the prototype analysis of the server verifiable AHSS, performed in \cite{VAHSS}, the finite field $\mathds{F}$ used for the secret shares generation is based on a $64$-bit prime number, i.e $\mathds{F}=\mathds{Z}_p$, where $p$ is a $64$-bit prime number,  but in the server and client verifiable AHSS the finite field is formed by a $256$-bit prime number.  The range proofs are based in libsecp256k1 library available in Go-Ethereum and uses elliptic curves and $128$-bit security, to provide this security level the underlying field has to be of size $\sim 256$-bits since the fastest known algorithm to solve elliptic curve discrete logarithm problem (ECDLP) requires $\mathcal{O}(\sqrt{n})$ steps. To use a common underlying field  for the both constructions,  the size of the field for the VAHSS is $256$-bit instead of $64$-bit. The hardware is the same as used above for benchmarking in section \ref{sec:PrototypeAnalysis}. For completeness it is repeated here; the computer used has a $1.6$ GHz Dual-Core Intel Core i$5-5250$U CPU, $8$GB $1600$ MHz DDR3 RAM  and running macOS $10.15$. 




%The size of the underlying range will vary to investigate the impact it has on runtime, both the complexity for the Bulletproofs and signature-based range proof depends on the size of the range unlike the set-membership as discussed above. 

A final remark about the implementation is that its purpose is to test the concept on the above proposed construction and provide runtime evaluations, the code has not been tested enough to be used as secure implementation.

%TODO Describe changes in their code

%bulletproofs, set membership proofs and signature based range proofs to  verify the clients input. in written in Golang. All three mentioned range proofs has previously been implemented in Golang and the code is available on Github at \cite{RP_code}. The server verifiable secret sharing construction has been implemented in python and c++ and is available at Github at \cite{Vahsss_code}. 


%The implementations is done in Golang. Specify all parameters used for the implementation. 
